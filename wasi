
cat << 'EOF'                    >k.wasi
(module
(import "wasi_unstable" "arg_sizes_get" (func $arg_sizes_get (param i32 i32) (result i32)))
(import "wasi_unstable" "args_get" (func $args_get(param i32 i32) (result i32)))
(import "wasi_unstable" "fd_read"  (func $fd_read  (param i32 i32 i32 i32) (result i32)))
(import "wasi_unstable" "fd_write" (func $fd_write (param i32 i32 i32 i32) (result i32)))
(import "wasi_unstable" "fd_seek"  (func $fd_seek  (param i32 i64 i32 i32) (result i32)))
(import "wasi_unstable" "fd_close" (func $fd_close (param i32) (result i32)))
(import "wasi_unstable" "path_open" (func $path_open (param i32 i32 i32 i32 i32 i64 i64 i32 i32) (result i32)))
(import "wasi_unstable" "proc_exit" (func $proc_exit (param i32) (result i32))
EOF

sed 1,8d k.wat | grep -v '^)' >>k.wasi


cat << 'EOF'                  >>k.wasi
(func $Exit (param i32)
 local.get 0
 call $proc_exit
 drop)
(func $Args (result i32)
 i32.const 512
 i32.const 516
 call $arg_sizes_get
 drop
 i32.const 512
 i32.load)
($func $Arg (param i32 i32) (result i32) (local $an i32) (local $i int64)
 i32.const 512
 i32.const 516
 call $arg_sizes_get
 drop

 i32.const 19
 i32.const 512
 i32.load
 call $mk
 local.tee $i
 i32.wrap_i64
 local.get 1
 call $args_get
 drop

 local.get 0
 i32.const 4
 i32.mul
 local.get $i
 i32.wrap_i64
 i32.add
 i32.load
 local.get 1
 i32.sub
 i32.set $an

 local.get 1
 local.get 1
 local.get $an
 i32.add
 local get $an
 memory.copy

 local.get $i
 call $dx

 i32.const 0
 local.get 0
 local.get 0
 i32.const 512
 i32.add
 call $idxc)
EOF

echo ")"                      >>k.wasi


#"Exit"  (func $Exit  (param i32)))
#"Args"  (func $Args  (result i32)))
#"Arg"   (func $Arg   (param i32) (param i32) (result i32)))
#"Read"  (func $Read  (param i32) (param i32) (param i32) (result i32)))
#"Write" (func $Write (param i32) (param i32) (param i32) (param i32) (result i32)))
#"ReadIn" (func $ReadIn (param i32) (param i32) (result i32)))
#"Native" (func $Native (param i64) (param i64) (result i64)))

