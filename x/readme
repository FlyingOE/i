k's source as a k table (k.k)

t:+`n`t`p`i`s!(!#T;T;P;I;S) /node type parent i-value s-value

k k.k go.k -e 'x:`"k.go"<go``'       /generate k.go main
k k.k go.k -e 'x:`"k.go"<go`lib`k'   /generate k.go lib
k k.k wa.k -e         '`<wa``'       /generate wasm(text) (wip)
k k.k cc.k -e 'x:`"k.c" <cc``'       /generate k.c main
next: js zz wb pa qb rv ha jv

a compiler backend implements a function per node type to transform the node into string form.
e.g. go transforms the table to a string of go program source code:

it folds the table in reverse order  f/[();|!#P;|n]
the first argument is a stack (of string results) and n is the child count per node:
 n:(&#P){x[y]+:1}/P; n[0]-:1
for each node, f cuts the number of children from the stack, calls the emitter based on the node's type
with arguments x:node id, and y the evaluated children in string form.
the result is catenated to the stack.

ast transformations(are done on the table before flattening), e.g.:
 -rename builtin functions [c]
 -rewrite cond/swtich expressions as statements (return or assign each) [go]
  same for c but keep ternary expressions
 -remove explicit zero assignments [go wa] todo
 

node type                    i-value             s-value
 prg     root node           -                   prog/libname    first node only
 mem     memory segment      #64k blocks         `a|`b           a|b: memory1|memory2
 con     constant            -                   name            child: lit
 var     global variable     -                   name            child: lit
 lit     literal (con|var)   val(32bit)|C-index  type
 tab     func table entry    index               func name
 fun     function            exported            func name       children: args res locs ast dfr
 arg     func argument       -                   type            child: sym
 sym     symbol              1(global)|0N(func)  name
 res     return value        -                   type            unnamed
 loc     local var decl      -                   type            child: sym
 ast     func ast root       -                   -               one per func
 stm     statement list      -                   -
 ret     return              -                   `|type          children: return values, s-type only for single res
 cal     function call       func node           func name       children: args
 cli     indirect call       #args               res-type        children: func-expr args arg-types
 drp     drop return vals    -                   -               child: cal
 get     get local           -                   varname
 Get     get global          -                   varname
 lod     load                -                   type(bijf)      child:    addr
 sto     store               -                   type(bijf)      children: addr, value
 asn     assignment          1(global)           varname         children: expr
 cst     cast                -                   dst type        2 children: typ(src), arg
 typ     type                -                   type
 cnd     if condition        -                   `|result-type   2|3 children: if then [else]
 swc     switch              1(has default)      `|result-type   children: expr cases [default]
 jmp     break/continue      1(break)|0(cont)    label
 for     loop                1(simple)           label           children: (cond|nop) (post|nop) body
 dfr     defer stmt node     -                   -               child: cal
 nop     ignore              -                   -
unary operator nodes
 neg|not                     1                   type            1 child
binary operator nodes
 eql|les|mor|gte|lte|and|orr 2                   type            2 children
 add|sub|mul|div|mod|shr|shl	
 xor|neq|ant(andnot)|bnd|bor(&& ||)			     
 
types: `i`u`j`k`f!(i32;u32;i64;u64;f64)
			     
the table is generated by github.com/ktye/wg/k.go
number of nodes:     #t             /35826
number of functions: #t{t=`fun}     /487
max depth:           |/dp P         /28


aaron's thesis:
3.2.4:table d(depth) t(primary class) k(sub class) n(name/reference)
3.2.6:I←{(⊂⍵)⌷⍺}
3.3:parent from depth
3.4:
 p:0 0 1 2 0 4 5 5 7 0 9 10 11 12 13 12 12 16 10 18 19 20 19 19 23 10 25
 p@&~3=t p            / (t[p]≠3)/p
 p p@&~3=t p          / p I (t[p]≠3)/p
 @[p;i;p p i:&~3=t p] / p I@{t[⍵]≠3} p    @(At) amends despite the name

