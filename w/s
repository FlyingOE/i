/ kwac
iv:7                       / ⍳/k7 switch, iv is a devvar in ⍳ always returning 1
I:0x7f;F:0x7c;C:0x41       / i32;f64;i32.const
x:0x2000;y:0x2001;z:0x2002 / local.get
num:{`c$x}                 / unsigned to LEB128, TODO x>127
add:0x6a                   / i32.add
f:`v!(I;"";"";C,num 0)     / exported function (single letter name)
f[`add]:(I;I,I;"";x,y,add) / ret;args;locals;body

/ mm
/ 8B header, buckets:[4..30] 16B..2GB
/ 3  +5 bit|   24bit    |       32bit       | values...
/ typ buckt|array length|next free/ref count|
/ types ifzscgld (i32,f64,z128,symbol32,char8,func32,list32,dict64)
/ 3bits for the k-type is not a lot, but:
/ free:   ^v&0xffffffe0 all bits 0 except bucket at 32-bit addr v
/ atomic:    v&0xe0=0   type bits are zero; type is stored in len; typ=v>>=8
/ vector:               type bits are nonzero; 
/ ext:     0x40=v&0xe0  vector list opens scalar extensions stored in len
/ numeric:    typ<s     ifz
/ compound:   typ>g     ld
/ 
/ f64 fits in the smallest bucket, f64 vectors are already aligned
/ max array length: 2^24 16Million (128MB f64)
/ initial memory: 64kB (1 wasm block) 
/ pointers to free list in first 128 byte (buck N @ 4xN):
/ xxx | 0x00000010 | ktree-addr | num-globals | ptr to bucket 4 | ..5 | ...
/ memory  4-7  currently allocated total memory (0x10 is 64kB), max 0x1f(4G)
/ memory  8-11 points to ktree, initial addr 128 (16x4B symbol + 16x4B pointers); relocate if exceed
/ symbols: max length 4B, value is itself as u32 (0padded)
/ [a-Z][a-Z0-9]{0,3} → 52*62*62*62 = 12393056 (no dot no underscore)

f[`ini]:(I;"";"";C,num 0)
/ f[`ini] 
/ for buck=15..8 do { 
/	divide
/	set header at 2^buck to ...
/	set free list at addr 4*buck to 2^buck
/ }
/ set initial headers..

/ https://webassembly.github.io/wabt/demo/wat2wasm/
/ https://github.com/sunfishcode/wasm-reference-manual/blob/master/WebAssembly.md

/ emit
o: 0x0061736d01000000         / header

/ 0x01(type section)
o,:0x01 
sig:{0x60,(`c$#x[1]),x[1],(`c$#x[0]),x[0]}
ft:()!()                      / map of function signatures
{ft[sig[x]]::1}'f;
oo:(`c$#!ft),,/!ft
o,:num[#oo],oo

/ 0x02(import section)
/ 0x03(function section, type declarations)
o,:0x03,(num 1+#f),num[#f]
o,:,/{num@&(!ft)~'(,#!ft)#,sig[x]}'f

/ 0x04(table section)
/ 0x05(linear memory section)
/ 0x06(global section)
/ 0x07(export section)
ln:{$[iv=1;#`\x;#$x]}         / all strings have length 1 in ⍳: need to split.
str:{$[iv=1;x;$x]}
ex:(!f)@&{1=ln x}'!f
o,:0x03,num[#ex]
g:{(num ln x),(str x),0x00,num[*&x=!f]}
oo:,/g'ex
o,:num[#oo],oo

/ 0x08(start section)
o,:0x0801,num@*&`ini=!f

/ 0x09(element section)
/ 0x0a(code section)
o,:0x0a,num@#f
/TODO: section size
/for each function
/ body size, array of locals (num, type), instructions

/ 0x0b(data section)

o