
//go:embed readme
var help []byte

var out *bufio.Writer

const separators = ",;|\t "

func main() {
	a := os.Args[1:]
	if len(a) == 0 || a[0] == "-h" {
		os.Stderr.Write(help)
		os.Exit(1)
	}

	fm, fi := "", ""
	if len(a) < 2 {
		fi = a[1]
		a = a[1:]
	} else {
		fm, fi = a[1], a[2]
		a = a[2:]
	}
	l := ""
	if len(a) > 0 {
		l = a[len(a)-1]
		if l == "-t" || l == "-b" || l == "-h" {
			a = a[:len(a)-1]
		} else {
			l = ""
		}
	}


	b, e := os.ReadFile(fi)
	if e != nil {
		fatal("cannot read csv file: "+fi)
	}

	x := kcsv(fm, b, l)
	if x == 0 {
		return
	}

	// todo store in x
	for i, s := range a {
		if strings.HasSuffix(s, ".k") {
			x := KC(s)
			dofile(x, readfile(rx(x)))
		} else if s == "-e" {
			if i == len(a) - 1 {
				os.Exit(0)
			}
			repl(KC(strings.ReplaceAll(a[1+i], "Â°", "'")))
			os.Exit(0)
		} else {
			os.Stderr.Write(help)
			fatal("cannot parse argument: "+s)
		}
	}

	// repl
	write(Ku(2932601077199979)) // "ktye/k\n"
        store()
        for {
                write(Ku(32))
                x := read()
                try(x)
        }
}

func kcsv(fm string, b []byte, l string) uint64 {
	var form format
	form, b = parseFormat(fm, b)

	if l == "-h" {
		colnames()
		return 0
	}

	kinit()

	_ = form
	// todo csv..
	return 0
}

type format struct {
	s byte
	t []byte
	i []int
}

func parseFormat(f string, b []byte) (format, []byte) {
	var h []byte
	var r format
	b = bytes.TrimSpace(b)
	if i := bytes.Index(b, []byte{10}); i > 0 {
		h = b[:i]	
	} else {
		fatal("csv file contains no newline")
	}

	// separator
	r.s = ' '
	if len(f) > 0 && strings.IndexByte(separators, f[0]) >= 0 {
		r.s, f = f[0], f[1:]
	} else {
		r.s = autosep(h)
	}
	if r.s == ' ' {
		sp := regexp.MustCompile(" +")
		b = sp.ReplaceAll(b, []byte{32})
	}

	// skip header
	if s, t, o := strings.Cut(f, "h"); o {
		nh, e := strconv.Atoi(s)
		if e != nil || nh < 0 {
			fatal("csv format: cannot read #h: "+f)
		}
		for i := 0; i<nh; i++ {
			//b = bytes.CutPrefix(b, []byte{10})
			if j := bytes.IndexByte(b, 10); j >= 0 {
				b = b[1+j:]
			}
		}
		f = t
	}

	cur := 0
	for len(f) > 0 {
		i := strings.IndexAny(f, "ifcsz")
		if i < 0 {
			fatal("csv format: cannot read type: "+f)
		} else if i == 0 {
			r.i = append(r.i, cur)
			r.t = append(r.t, f[0])
			f = f[1:]
			cur++
			if f[0] == 'z' {
				cur++
			}
		} else {
			if n, e := strconv.Atoi(f[:i]); e != nil {
				fatal("csv format: cannot parse int: "+f)
			} else {
				r.i = append(r.i, n)
				r.t = append(r.t, f[i])
				cur = n
				if f[i] == 'z' {
					cur++
				}
				f = f[1+i:]
			}
		}
	}
	return r, b
}
func autosep(h []byte) byte {
	a, m, j := separators, -1, 0
	for i, c := range a {
		if n := bytes.Count(h, []byte{byte(c)}); n > m {
			m, j = n, i
		}
	}
	return a[j]
}

func colnames() { println("todo") }
func fatal(s string) {
	os.Stderr.Write([]byte(s))
	os.Stderr.Write([]byte{10})
	os.Exit(1)
}

func KC(s string) uint64 {
	r := mk(18, int32(len(s)))
	copy(Bytes[int32(r):], []byte(s))
	return r
}
/*
func CK(x uint64) string { dx(x); return string(Bytes[int32(x) : int32(x)+nn(x)]) }
func KL(v []string) uint64 {
	r := mk(23, int32(len(v)))
	p := int32(r)
	for i := range v {
		SetI64(p+8*int32(i), int64(KC(v[i])))
	}
	return r
}
func eval(x uint64) string {
	return strs(exec(rx(x)))
}
func writes(x []string) { out.WriteString(strings.Join(x, " ") + "\n") }
func strs(x uint64) (r string) {
	p := int32(x)
	t := tp(x)
	switch t {
	case 2:
		r = string(p)
	case 3:
		r = strconv.Itoa(int(p))
	case 4:
		r = CK(cs(rx(x)))
	case 5:
		r = ftoa(F64(p))
	case 6:
		r = absang(complex(F64(p), F64(p+8)))
	case 18:
		r = CK(rx(x)) // C
	case 19, 20, 21, 22, 23:
		r = each(x) // IFSZL
	}
	dx(x)
	return r
}
func each(x uint64) string {
	n := nn(x)
	r := make([]string, n)
	for i := int32(0); i < n; i++ {
		r[i] = strs(ati(rx(x), i))
	}
	return strings.Join(r, " ")
}
func ftoa(f float64) string { return strconv.FormatFloat(f, 'g', 6, 64) }
func absang(z complex128) string {
	ang := 180.0 / math.Pi * cmplx.Phase(z)
	if ang < 0 {
		ang += 360.0
	}
	return ftoa(cmplx.Abs(z)) + " " + ftoa(ang)
}
*/
