package i

import (
	"testing"
)

/*
func TestP(t *testing.T) {
	testCases := []struct {
		s s
		r l
	}{
		{"", l{}},
		{";", l{nil}},
	}
	for _, tc := range testCases {
		r := P(tc.s)
		_fmt.Printf("prs: %q %+v\n", tc.s, r) // TODO: change to printf
		if reflect.DeepEqual(r, tc.r) == false {
			_fmt.Printf("exp: %+v\n", tc.r) // TODO: change to printf
			_fmt.Printf("got: %+v\n", r)    // TODO: change to printf
			t.Fatal()
		}
	}
}
*/

func TestScan(t *testing.T) {
	type iv [12]i //0     1     2     3     4     5     6     7     8     9    10    11
	var f = [12]sf{sNum, sNam, sSym, sStr, sVrb, sAsn, sIov, sAdv, sViw, sCnd, sDct, sWsp}
	var testCases = []struct {
		s s
		r iv
	}{
		{` `, iv{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}},
		{`0`, iv{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{`23`, iv{2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{`+1`, iv{2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}}, // +1 is a number
		{`-1`, iv{2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}},
		{`1e`, iv{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{`1.`, iv{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{`.5`, iv{0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}},  // no number: .5 use 0.5
		{`1j`, iv{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},  // no number: 1j
		{`0j1`, iv{3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, // complex i: 0i1 or 0j1
		{`-1i0`, iv{4, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}},
		{`j`, iv{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{`-j`, iv{0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}},
		{`1.23e+06j-1.23e-13`, iv{18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{`13.275a275.2`, iv{12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{`π`, iv{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, // name!
		{`a`, iv{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{`a2`, iv{0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{`a2/`, iv{0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{"`a", iv{0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{"`a3", iv{0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{"`a3.", iv{0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{`"a"`, iv{0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0}},
		{`"a"b`, iv{0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0}},
		{`"a\"b\n"b`, iv{0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0}},
		{`+`, iv{0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}},
		{`⍟3`, iv{0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}},
		{`⍟:`, iv{0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0}},
		{`+:`, iv{0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0}},
		{`1:`, iv{1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0}},
		{`/`, iv{0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}},
		{`':`, iv{0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0}},
		{`⍨`, iv{0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}},
		{`::x`, iv{0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0}},
		{`$[`, iv{0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0}},
		{`[`, iv{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{`[:`, iv{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{`[3:`, iv{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{`[a:`, iv{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0}},
		{`[a3:`, iv{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0}},
		{`[ab3:`, iv{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0}},
		{`  \n `, iv{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2}},
		{"  \t\r ", iv{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5}},
	}
	for _, tc := range testCases {
		for k, f := range f {
			if n := f([]rune(tc.s)); n != tc.r[k] {
				t.Fatalf("%q: f[%d] got %d, exp %d", tc.s, k, n, tc.r[k])
			}
		}
	}
}

/*
func TestPBeg(t *testing.T) {
	testCases := []struct {
		s, r string
	}{
		{"", ""},
		{"x", "x"},
		{"a-x;", "a- x;"},
		{"a-3.1x", "a-3.1x"},
		{"\rab\r", "ab"},
		{"x\n+3", "x;+3"},
		{"x\n+/", "x;+ /"},
	}
	for _, tc := range testCases {
		r := string(pbeg(rv(tc.s)))
		if r != tc.r {
			t.Fatalf("%q: exp: %q got: %q", tc.s, tc.r, r)
		}
	}
}
*/
