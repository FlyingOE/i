⍳ interpret - a k interpreter for Go

Package interface (2 functions, no types):
  l := P("!3")  // Parse expr to ast (list []interface{})
  v := E(l, a)  // Evaluate to value (interface{})
  //k-tree: a map[interface{}]interface{}

Types
    float64,   complex128      numbers
  []float64, []complex128      uniform vectors
  []interface{}                list
  []rune                       character array
  string                       symbol
  map[interface{}]interface{}  dict (`_ is reserved)
  func                         function
Any Go variable that is present in the k-tree can be used as well:
  any slice                    list
  any map or struct            dict (string keys for structs)
  any numeric type             number
  any function can be called
  any type implementing a verb interface can be used:
    monadic: func (t myType) Neg() interface{}
    dyadic:  func (t myType) Add(y interface{}, tLeft bool) interface{}
  called for each scalar, or a single call if t is a slice

Verbs
    a     l     a-a   l-a   a-l   l-l 
+   flp   flp  [add] [add] [add] [add]  ⍉
-  [neg] [neg] [sub] [sub] [sub] [sub]   
*   fst   fst  [mul] [mul] [mul] [mul]  ×
%  [inv] [inv] [div] [div] [div] [div]  ÷
!   til   odo   mod    -    mod>  mkd   ⍳
&   wer   wer  [min] [min] [min] [min]  ⍸⌊
|   rev   rev  [max] [max] [max] [max]  ⌽⌈
<   asc   asc  [les] [les] [les] [les]  ⍋
>   dsc   dsc  [mor] [mor] [mor] [mor]  ⍒
=   eye   grp  [eql] [eql] [eql] [eql]  ⌸
~  [not] [not]  mch   mch   mch   mch   ≡
,   enl   enl   cat   cat   cat   cat   
^   is0  [is0]  ept   ept   ept   ept   
#   cnt   cnt   tak   rsh   tak   rsh   ⍴↑ 
_  [flr] [flr]  drp   drp   drp   cut   ⌊↓
$   fmt  [fmt]  cst   cst   cst   cst   ⍕
?   rng   unq   rnd   fnd   rnd   fnd>  ∪
@   typ   typ   atx   atx   atx   atx   
.   evl   evl   cal   cal   cal   cal   
/    -     -     -     -    pak   pak     
\    -     -     -    upk   spl   -      
                                                 
Adverbs                                 :← prs⍎
    mv/nv dv    l-mv  l-dv  3+v         x⍺
':   -    ecp    -    ecp    -    ⍨     y⍵
'   ech   ecd   ecd   ecd   eca   ¨     o∇ inf∞ nanø piπ
/:   -     -    ecr   ecr    -    ⌿     sqr√ log⍟ pow,exp⍣
\:   -     -    ecl   ecl    -    ⍀     sin cos tan
/   fxd   ovr   fxw   ovd   ova         abs‖ ang deg
\   scf   scn   scw   scd   sca         reℜ imℑ con

Ref
  github.com/JohnEarnest/ok

Status nyi
  This is a slow version of k. It does no ref-counting, copies everything
  and is based on type reflection. It's focus is direct integration into
  the go type system, to be usable by existing programs with minimal glue.
  