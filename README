⍳ interpret - a k interpreter for Go

Package interface (2 functions, no types):
  l := P("!3")  // Parse expr to ast (list []interface{})
  v := E(l, a)  // Evaluate to value (interface{})
  //k-tree: a map[interface{}]interface{}

Types
    float64,   complex128      numbers    1 -2.3 5e6 1i0 3a270
  []float64, []complex128      uniform vectors       1 2.3 -55
  []interface{}                list       (1;2;3;`b;"x";(4;5))
  []rune                       character array   "alpha\nbeta"
  string                       symbol  `single  `a`symbol`list
  map[interface{}]interface{}  dict (`_ is reserved) [a:1;b:2]
  func                         function                      +
Any Go variable present in the k-tree can be used as well:
  any slice                    list                 []mytype{}
  any map or struct            dict (string keys for structs)
  any numeric type             number
  any function can be called                          func(){}
  get methods with @           f:mytype@`m;f[3] or mytype.m[3]

Verbs
    a     l     a-a   l-a   a-l   l-l 
+   flp   flp  [add] [add] [add] [add]  ⍉
-  [neg] [neg] [sub] [sub] [sub] [sub]   
*   fst   fst  [mul] [mul] [mul] [mul]  ×
%  [inv] [inv] [div] [div] [div] [div]  ÷
!   til   odo   mod    -    mod>  mkd   ⍳
&   wer   wer  [min] [min] [min] [min]  ⍸⌊
|   rev   rev  [max] [max] [max] [max]  ⌽⌈
<   asc   asc  [les] [les] [les] [les]  ⍋
>   dsc   dsc  [mor] [mor] [mor] [mor]  ⍒
=   eye   grp  [eql] [eql] [eql] [eql]  ⌸
~  [not] [not]  mch   mch   mch   mch   ≡
,   enl   enl   cat   cat   cat   cat   
^   is0  [is0]  ept   ept   ept   ept   
#   cnt   cnt   tak   rsh   tak   rsh   ⍴↑ 
_  [flr] [flr]  drp   drp   drp   cut   ⌊↓
$   fmt  [fmt]  cst   cst   cst   cst   ⍕
?   rng   unq   rnd   fnd   rnd   fnd>  ∪
@   typ   typ   atx   atx   atx   atx   
.   evl   evl   cal   cal   cal   cal   
/    -     -     -     -    pak   pak     
\    -     -     -    upk   spl   -      
                                                 
Adverbs                           
    mv/nv dv    l-mv  l-dv        x⍺   y⍵   o∇
'   ech   ecd   ecd   ecd   ¨     prs  evl
':   -    ecp    -    eci   ⍨     inf∞ nanø piπ
/:   -     -    ecr   ecr   ⌿     sqr√ log⍟ pow,exp⍣
\:   -     -    ecl   ecl   ⍀     sin  cos  tan
/   fidx  ovr   whl   ovd         abs‖ ang  deg
\   sfx   scn   swl   sci         reℜ  imℑ  con

Ref
  github.com/JohnEarnest/ok

Status nyi
  This is a slow version of k. It does no ref-counting, copies everything
  and is based on type reflection. It's focus is direct integration into
  the go type system, to be usable by existing programs with minimal glue.
  