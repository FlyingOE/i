package main
import (
	"bytes"
	"fmt"
	//"io/ioutil"
	"math"
	"math/bits"
	"math/cmplx"
	//"os"
	"strconv"
	"strings"
	"unsafe"
)
func main() { kinit(); gio() }
func init() {
	NAN = math.Float64frombits(18444492273895866368) // 0/0 (not math.NaN)
	INFINITY = math.Inf(1)
}
type C=byte
type I=uint32
type J=uint64
type F=float64
type SI=int32
type slice struct {
	p uintptr
	l int
	c int
}
var MB []C //backup
var MC []C
var MI []I
var MJ []J
var MF []F
var NAN, INFINITY F
func sin(x F) F { return math.Sin(x) }
func cos(x F) F { return math.Cos(x) }
func log(x F) F { return math.Log(x) }
func atan2(x, y F) F { return math.Atan2(x, y) }
func hypot(x, y F) F { return math.Hypot(x, y) }
func draw(x, y, z I) { fmt.Printf("draw %x %x %x\n", x, y, z) }
func msl() { // update slice headers after set/inc MJ
	cp := *(*slice)(unsafe.Pointer(&MC))
	ip := *(*slice)(unsafe.Pointer(&MI))
	jp := *(*slice)(unsafe.Pointer(&MJ))
	fp := *(*slice)(unsafe.Pointer(&MF))
	fp.l, fp.c, fp.p = jp.l, jp.c, jp.p
	ip.l, ip.c, ip.p = jp.l*2, jp.c*2, jp.p
	cp.l, cp.c, cp.p = ip.l*4, ip.c*4, ip.p
	MF = *(*[]F)(unsafe.Pointer(&fp))
	MI = *(*[]I)(unsafe.Pointer(&ip))
	MC = *(*[]byte)(unsafe.Pointer(&cp))
}
func grow(x I) I { panic("nyi grow"); return x }
func printc(x, y I) { fmt.Printf("%s\n", string(MC[x:x+y])) }
func clz32(x I) I { return I(bits.LeadingZeros32(x)) }
func clz64(x J) I { return I(bits.LeadingZeros64(x)) }
func i32b(x bool) I { if x { return 1 } else { return 0 } }
func n32(x I) I { if x == 0 { return 1 } else { return 0 } }
func dump(a, n I) { // type: cifzsld -> 2468ace
	p := a >> 2
	fmt.Printf("%.8x ", a)
	for i := I(0); i < n; i++ {
		x := MI[p+i]
		fmt.Printf(" %.8x", x)
		if i > 0 && (i+1)%8 == 0 {
			fmt.Printf("\n%.8x ", a+4*i+4)
		} else if i > 0 && (i+1)%4 == 0 {
			fmt.Printf(" ")
		}
	}
	fmt.Println()
}
func X(x I) string { //kst(go-version for debug)
	type s = string
	type i = I
	Z := func(a i) complex128 { return complex(MF[a>>3], MF[1+a>>3]) }
	if x == 0 || x == 128 {
		return ""
	}
	var t, n i
	n = 1
	if x > 255 {
		u := MI[x>>2]
		t = u>>29
		n = u&536870911
	}
	var f func(i i) s
	var tof func(s) s = func(s s) s { return s }
	istr := func(i i) s { return strconv.Itoa(int(int32(MI[i+2+x>>2]))) }
	fstr := func(i i) s {
		if f := MF[i+1+x>>3]; math.IsNaN(f) {
			return "0n"
		} else {
			return strconv.FormatFloat(f, 'g', -1, 64)
		}
	}
	zstr := func(i i) s {
		if z := Z(x + 8 + 16*i); cmplx.IsNaN(z) {
			return "0ni0n"
		} else {
			return strconv.FormatFloat(real(z), 'g', -1, 64) + "i" + strconv.FormatFloat(imag(z), 'g', -1, 64)
		}
	}
	sstr := func(i i) s {
		r := MI[(x + 8 + 4*i)>>2]
		rn := nn(r)
		return string(MC[r+8 : r+8+rn])
	}
	sep := " "
	switch t {
	case 0:
		fc := []byte(":+-*%&|<>=!~,^#_$?@.'/\\")
		if x < 128 && bytes.Index(fc, []byte{byte(x)}) != -1 {
			return string(byte(x))
		} else if x < 256 && bytes.Index(fc, []byte{byte(x - 128)}) != -1 {
			return string(byte(x-128)) + ":"
		} else if n == 3 {
			r := X(MI[(x + 12)>>2])
			return X(MI[(x+8)>>2]) + "[" + r[1:len(r)-1] + "]"
		} else if n == 4 {
			return sstr(0)
		} else {
			return fmt.Sprintf(" '(%d)", x)
		}
	case 1:
		return "\"" + string(MC[x+8:x+8+n]) + "\""
	case 2:
		f = istr
	case 3:
		f = fstr
		tof = func(s s) s {
			if strings.Index(s, ".") == -1 {
				return s + ".0"
			}
			return s
		}
	case 4:
		f = zstr
	case 5:
		f = sstr
		sep = string(96)
		if n == 0 { return "0#"+sep }
		tof = func(s s) s { return sep + s }
	case 6:
		if n == 1 {
			return "," + X(MI[(8+x)>>2])
		}
		f = func(i i) s { return X(MI[2+i+x>>2]) }
		sep = ";"
		tof = func(s s) s { return "(" + s + ")" }
	case 7:
		return X(MI[(x+8)>>2]) + "!" + X(MI[(x+12)>>2])
	default:
		panic(fmt.Sprintf("nyi: kst: t=%d", t))
	}
	r := make([]s, n)
	for k := range r {
		r[k] = f(i(k))
	}
	return tof(strings.Join(r, sep))
}
func ksave() {
	if len(MB) < len(MC) {
		MB = make([]C, len(MC))
	}
	copy(MB, MC)
}
func kinit() {
	m0 := 16
	MJ = make([]J, (1<<m0)>>3)
	msl()
	mt_init()
	ini(16)
	ksave()
}
func fatal(e error) { if e != nil { panic(e) } }
