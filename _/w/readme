# webassembly compiler(draft)
# 
# write wasm by hand, but more compact than wat
# 
# the input file compiles to a wasm module.
# it contains a collection of functions.
# 
# add:I:II::2000 2001 6a
#     function with name "add"
#     1 return argument (int)
#     2 input arguments (both int)
#     no local variables
#     function body
#         get local 0 (arguments and locals are catenated)
#         get local 1
#         int32.add
#     end is implicit
# 
# todo: k/apl style, type inference (for operators), control flow (loop, if), memory access, detect locals
# e.g.
# addi:I:II:x+y                   /local.get 0; local.get 1; i32.add
# addf:F:FF:x+y                   /local.get 0; local.get 1; f64.add (needs to be inferred)
# sumf:F:II:r:0.;yN(r:r+x↓F;x+:8) /sum float vector at memory location x with y elements
# sumi:I:II:r:0.;yN(r:r+x↓F;x+:4)

printf "add:I:II::2000 2001 6a\n" | go run w.go -html > index.html
# open file://.../index.html in a browser, in js console: k.add(1,2)
