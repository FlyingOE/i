// tcc -o kw.o -c kw_c
// tcc -o k.exe -DDRW k_c kk.o -luser32 -lgdi32
// tcc's kernel32.def is missing the export for GetConsoleWindow.
//  append GetConsoleWindow to $tcc/lib/kernel32.def
#include<stdio.h>
#include<windows.h>
HBITMAP screenBitmap(HDC hdc, int w, int h, char *p) {
	BITMAPV5HEADER   bi;
	HBITMAP          hbm;
	char            *dst;
	ZeroMemory(&bi, sizeof(BITMAPV5HEADER));
	bi.bV5Size = sizeof(bi);
	bi.bV5Height = h; bi.bV5Width = w; bi.bV5Planes = 1; bi.bV5BitCount = 32; bi.bV5Compression = 3; 
	//bi.bV5XPelsPerMeter = 3780; bi.bV5YPelsPerMeter = 3780;
	bi.bV5RedMask = 0x000000FF; bi.bV5GreenMask = 0x0000FF00; bi.bV5BlueMask = 0x00FF0000, bi.bV5AlphaMask = 0xFF000000;
	hbm = CreateDIBSection(hdc, &bi, 0, &dst, 0, 0);
	if (hbm == NULL) {
        	// free(pbmi);
        	return NULL;
	}


	// Why is the image upside down?
	// memcpy(dst, p, 4*w*h);
	int32_t *idst = (int32_t*)dst;
	int32_t *ip   = (int32_t*)p;
	int h1 = h-1;
	for(int k=0;k<h;k++)for(int i=0;i<w;i++)idst[w*(h1-k)+i]=ip[w*k+i];


	return hbm;
}
void draw0(int w, int h, char *p) {
	HDC hdc = GetDC(GetConsoleWindow());
	HDC hdcmem = CreateCompatibleDC(hdc);
	HBITMAP hbm = screenBitmap(hdc, w, h, p);
	HGDIOBJ o;
	if (hbm == NULL) return;
	o = SelectObject(hdcmem, hbm);
	if (o == 0) return;
	BitBlt(hdc, 0, 0, w, h, hdcmem, 0, 0, 0x00CC0020);
	SelectObject(hdcmem, o);
	DeleteDC(hdcmem);
	DeleteDC(hbm);
}
