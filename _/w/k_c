#include<stdlib.h>
#include<stdio.h>
#include<stddef.h>
#include<malloc.h>
#include<string.h>
#include<math.h>
#define R return
typedef void V;typedef char C;typedef int32_t I;typedef int64_t J;typedef double F;typedef uint32_t uI;typedef uint64_t uJ;
I __builtin_clz(I x){I r;__asm__("bsr %1, %0" : "=r" (r) : "rm" (x) : "cc");R r^31;}
V trap() { exit(1); }
C *MC;I* MI;J* MJ;F *MF;I ini(I);I bk(I,I);I mk(I,I);I mki(I);I mkd(I,I);V  fr(I);V  dx(I);V  rx(I);V  rl(I);I til(I);I rev(I);I atx(I,I);I fst(I);
I ini(I x0){I x1=0;I x2=0;MJ[0>>3]=(J)1130366807310592;MI[128>>2]=(I)x0;x1=256;x2=8;while((x2<(uI)x0)){MI[(4*x2)>>2]=(I)x1;x1=(x1*2);x2=(x2+1);}R x0;}
I bk(I x0,I x1){R (32-(__builtin_clz((7+((x1*((I)MC[x0])))))));}
I mk(I x0,I x1){I x2=0;I x3=0;I x4=0;I x5=0;I x6=0;x2=bk(x0,x1);x3=(4*x2);while(!(MI[x3>>2])){x3=(x3+4);}if((128==x3)){trap();}x4=MI[x3>>2];MI[x3>>2]=(I)MI[x4>>2];x5=(x3-4);while((x5>=(uI)((4*x2)))){x6=(x4+((1<<((x5>>(uI)2)))));MI[x6>>2]=(I)MI[x5>>2];MI[x5>>2]=(I)x6;x5=(x5-4);}MI[x4>>2]=(I)(x1|((x0<<29)));MI[(x4+4)>>2]=(I)1;R x4;}
I mki(I x0){I x1=0;x1=mk(2,1);MI[(x1+8)>>2]=(I)x0;R x1;}
I mkd(I x0,I x1){I x2=0;I x3=0;I x4=0;I x5=0;I x6=0;I x7=0;I x8=0;x2=((MI[x0>>2])>>(uI)29);x3=((MI[x0>>2])&536870911);x4=(8+x0);x5=((MI[x1>>2])>>(uI)29);x6=((MI[x1>>2])&536870911);x7=(8+x1);if((x2==5)){trap();}if((x3==x6)){trap();}x8=mk(7,2);MI[(x8+8)>>2]=(I)x0;MI[(x8+12)>>2]=(I)x1;R x8;}
V  fr(I x0){I x1=0;I x2=0;I x3=0;I x4=0;x1=((MI[x0>>2])>>(uI)29);x2=((MI[x0>>2])&536870911);x3=(8+x0);x4=(4*(bk(x1,x2)));MI[x0>>2]=(I)MI[x4>>2];MI[x4>>2]=(I)x0;;}
V  dx(I x0){I x1=0;if((x0>(uI)255)){x1=MI[(x0+4)>>2];MI[(x0+4)>>2]=(I)(x1-1);if((1==x1)){fr(x0);}};}
V  rx(I x0){if((x0>(uI)255)){x0=(x0+4);MI[x0>>2]=(I)(1+(MI[x0>>2]));};}
V  rl(I x0){I x1=0;I x2=0;I x3=0;I x4=0;x1=((MI[x0>>2])>>(uI)29);x2=((MI[x0>>2])&536870911);x3=(8+x0);x0=(x0+8);for(x4=0;x4<x2;x4++){rx(x0);x0=(x0+4);};}
I til(I x0){I x1=0;I x2=0;I x3=0;I x4=0;I x5=0;I x6=0;I x7=0;x1=((MI[x0>>2])>>(uI)29);x2=((MI[x0>>2])&536870911);x3=(8+x0);if(!((2==x1))){trap();}x4=MI[x3>>2];x5=mk(x1,x4);x6=(8+x5);for(x7=0;x7<x4;x7++){MI[x6>>2]=(I)x7;x6=(x6+4);}dx(x0);R x5;}
I rev(I x0){I x1=0;I x2=0;I x3=0;I x4=0;I x5=0;I x6=0;I x7=0;x1=((MI[x0>>2])>>(uI)29);x2=((MI[x0>>2])&536870911);x3=(8+x0);if(!x2){return x0;}if((x1>(uI)5)){rl(x0);}if((x1==7)){dx(x0);return mkd(rev((x0+8)),rev((x0+12)));}x4=mk(x1,x2);x5=(8+x4);x6=0;switch(x1){case 1:x5=(x5+((1*((x2-1)))));for(x7=0;x7<x2;x7++){MC[(x5-x6)]=(C)MC[(x3+x6)];x6=(x6+1);}break;case 3:x5=(x5+((8*((x2-1)))));for(x7=0;x7<x2;x7++){MF[(x5-x6)>>3]=(F)MF[(x3+x6)>>3];x6=(x6+8);}break;case 4:trap();break;default:x5=(x5+((4*((x2-1)))));for(x7=0;x7<x2;x7++){MI[(x5-x6)>>2]=(I)MI[(x3+x6)>>2];x6=(x6+4);}}dx(x0);R x4;}
I atx(I x0,I x1){I x2=0;I x3=0;I x4=0;I x5=0;I x6=0;I x7=0;I x8=0;I x9=0;I x10=0;x2=((MI[x0>>2])>>(uI)29);x3=((MI[x0>>2])&536870911);x4=(8+x0);x5=((MI[x1>>2])>>(uI)29);x6=((MI[x1>>2])&536870911);x7=(8+x1);if((x2==7)){trap();}if(!((x5==2))){trap();}x8=mk(x2,x6);x9=(x8+8);switch(x2){case 0:trap();break;case 1:for(x10=0;x10<x6;x10++){MC[(x9+x10)]=(C)(C)32;if((x10<(uI)x3)){MC[(x9+x10)]=(C)MC[(x4+x10)];}}break;case 2:for(x10=0;x10<x6;x10++){MI[x9>>2]=(I)-2147483648;if((x10<(uI)x3)){MI[x9>>2]=(I)MI[x4>>2];}x9=(x9+4);x4=(x4+4);}break;default:trap();}dx(x0);dx(x1);R x8;}
I fst(I x0){I x1=0;I x2=0;I x3=0;x1=((MI[x0>>2])>>(uI)29);x2=((MI[x0>>2])&536870911);x3=(8+x0);if((x1==7)){rx((12+x0));dx(x0);return fst((12+x0));}R atx(x0,mki(1));}
// Postfix test interface: e.g. 5 mki til rev fst 0 500 dump
const trace = 0;
I pop1(I *s, I n, I *x) {
	*x = s[n-1];
	return n-1;
}
I pop2(I *s, I n, I *x, I *y) {
	*x = s[n-2];
	*y = s[n-1];
	return n-2;
}
I push(I *s, I n, I x) {
	s[n] = x;
	return n+1;
}
I f1(I (*f)(I), I *s, I n) {
	if(trace) printf("%d: ", s[n-1]);
	s[n-1] = f(s[n-1]);
	if(trace) printf("%d\n", s[n-1]);
	return n;
}
I f2(I (*f)(I,I), I *s, I n) {
	if(trace) printf("%d %d: ", s[n-2], s[n-1]);
	s[n-2] = f(s[n-2], s[n-1]);
	if(trace) printf("%d\n", s[n-2]);
	return n-1;
}
I Number(C *s) {
	R strtol(s, (C **)NULL, 10);
}
I Match(C *a, C *b) {
	for (I i=0; ;i++) {
		if (a[i] != b[i]) return 0;
		if (a[i] == 0)    return 1;
	}
}
I Dump(I *s, I n) {
	I x = s[n-2];
	I y = s[n-1];
	I p = 0;
	printf("\n%08x  ", x);
	for (I i=x; i<x+y; i++) {
		printf("%02x", (uint8_t)MC[i]);
		p++;
		if ((i > x) && (p%32 == 0)) {
			printf("\n%08x  ", i+1);
		} else if ((i > x) && (p%4 == 0)) {
			printf(" ");
		}
	}
	return n-2;
}
V O(I x) {
	I i;
	I t = MI[x>>2]>>29;
	I n = MI[x>>2]&536870911;
	switch(t){
	case 1:
		printf("\"");
		for(i=0;i<n;i++) printf("%c", MC[8+x+i]);
		printf("\"\n");
		break;
	case 2:
		x = 2 + (x>>2);
		for(i=0;i<n;i++) {
			if (i>0) {
				printf(" ");
			}
			printf("%d", MI[x+i]);
		}
		printf("\n");
		break;
	default: printf("nyi: kst%d\n", t);trap();
	}
}
#define M0 16
I main(int args, C **argv){
	MC=malloc(1<<M0);MI=(I*)MC;MJ=(J*)MC;MF=(F*)MC;
	memset(MC, 0, 1<<M0);
	I stack[32];
	I i, n = 0;
	I x, y, r;
	C *a;
	ini(M0);
	for (i=1; i<args; i++) {
		a = argv[i];
		if (a[0] >= '0' && a[0] <= '9') {
			n = push(stack, n, Number(a));
			continue;
		}
		//printf("%s ", argv[i]);
		if (Match("mki", a)) {
			n = f1(mki, stack, n);
		} else if (Match("bk", a)) { n = f2(bk, stack, n);
		} else if (Match("mk", a)) { n = f2(mk, stack, n);
		} else if (Match("mkd", a)) { n = f2(mkd, stack, n);
		} else if (Match("til", a)) { n = f1(til, stack, n);
		} else if (Match("rev", a)) { n = f1(rev, stack, n);
		} else if (Match("atx", a)) { n = f2(atx, stack, n);
		} else if (Match("fst", a)) { n = f1(fst, stack, n);
		} else if (Match("dump", a)) {
			n = Dump(stack, n);
		} else if ((a[0] == '"') && strlen(a) > 1) {
			x = strlen(a) - 2;
			r = mk(1, x);
			for (i=0; i<x; i++) MC[8+i+r] = a[1+i];
			n = push(stack, n, r);
		} else {
			printf("arg!");
			trap();
		}
	}
	if (n != 1) { printf("stack (%d)", n);trap(); }
	O(stack[0]);
}
