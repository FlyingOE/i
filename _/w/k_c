// compile without drawing
//  $ tcc -o kw.exe k_c
// compile with draw support (win32-only)
//  tcc's kernel32.def is missing the export for GetConsoleWindow.
//  append GetConsoleWindow to $tcc/lib/kernel32.def
//  $ tcc -o kw.exe -DDRW k_c -luser32 -lgdi32
//
// both use k_h+h_h which are autogenerated by "go test" from ../../k.w

#include<stdlib.h>
#include<stdio.h>
#include<stddef.h>
#include<setjmp.h>
#include<malloc.h>
#include<string.h>
#include<math.h>

#define R return
typedef void V;typedef char C;typedef uint32_t I;typedef uint64_t J;typedef double F;typedef int32_t SI;typedef int64_t SJ;
I __builtin_clz(I x){I r;__asm__("bsr %1, %0" : "=r" (r) : "rm" (x) : "cc");R r^31;}
C *MC;I* MI;J* MJ;F *MF;
static jmp_buf jb;
V panic(){printf("k.w:%u:%u\n", MI[140>>2], MI[144>>2]);longjmp(jb,1);}
V sC(I x,C y){MC[x]=y;}V sI(I x,I y){MI[x>>2]=y;}V sF(I x,F y){MF[x>>3]=y;}V sJ(I x,J y){MJ[x>>3]=y;};
//F NaN = &((unt64_t)9221120237041090561ull);
V dump(I,I);
I grow(I x){MC=realloc(MC, 1<<x);MI=(I*)MC;MJ=(J*)MC;MF=(F*)MC; R x;}

#ifndef DRW
V draw0(I x,I y,C *z){printf("draw..\n");}
#else
#include<windows.h>
HBITMAP screenBitmap(HDC hdc, int w, int h, char *p) {
	BITMAPV5HEADER   bi;
	HBITMAP          hbm;
	char            *dst;
	ZeroMemory(&bi, sizeof(BITMAPV5HEADER));
	bi.bV5Size = sizeof(bi);
	bi.bV5Height = h; bi.bV5Width = w; bi.bV5Planes = 1; bi.bV5BitCount = 32; bi.bV5Compression = 3; 
	//bi.bV5XPelsPerMeter = 3780; bi.bV5YPelsPerMeter = 3780;
	bi.bV5RedMask = 0x000000FF; bi.bV5GreenMask = 0x0000FF00; bi.bV5BlueMask = 0x00FF0000, bi.bV5AlphaMask = 0xFF000000;
	hbm = CreateDIBSection(hdc, &bi, 0, &dst, 0, 0);
	if (hbm == NULL) {
        	// free(pbmi);
        	return NULL;
	}


	// Why is the image upside down?
	// memcpy(dst, p, 4*w*h);
	int32_t *idst = (int32_t*)dst;
	int32_t *ip   = (int32_t*)p;
	int h1 = h-1;
	for(int k=0;k<h;k++)for(int i=0;i<w;i++)idst[w*(h1-k)+i]=ip[w*k+i];


	return hbm;
}
void draw0(int w, int h, char *p) {
	HDC hdc = GetDC(GetConsoleWindow());
	HDC hdcmem = CreateCompatibleDC(hdc);
	HBITMAP hbm = screenBitmap(hdc, w, h, p);
	HGDIOBJ o;
	if (hbm == NULL) return;
	o = SelectObject(hdcmem, hbm);
	if (o == 0) return;
	BitBlt(hdc, 0, 0, w, h, hdcmem, 0, 0, 0x00CC0020);
	SelectObject(hdcmem, o);
	DeleteDC(hdcmem);
	DeleteDC(hbm);
}
#endif
V draw(I x, I y, I z){draw0(x,y,MC+z);}
#undef abs
#undef min
#undef max

#include"k_h"

V dump(I x, I n) {
	I p = x>>2;
	printf("\n%08x  ", x);
	for (I i=0; i<n; i++) {
		printf(" %08x", MI[p+i]);
		if ((i > x) && ((i+1)%8 == 0))      printf("\n%08x  ", x+4*i+4);
		else if ((i > 0) && ((i+1)%4 == 0)) printf(" ");
	}
	printf("\n");
}
V pstr(I x) {
	I n = (MI[x>>2])&536870911;
	for(I i=0;i<n;i++) printf("%c", MC[8+x+i]);
	dx(x);
}
V O(I x) { if(!x)R; pstr(kst(x)); printf("\n"); }
#define M0 16
I chrs(C *s) {
	I n = strlen(s);
	I x = mk(1, n);
	for (I i=0; i<n; i++) MC[8+x+i] = s[i];
	R x;
}
V runtest() {
	C buf[128];
	C *p;
	while (fgets(buf, 128, stdin) != NULL) {
		if((p=strstr(buf, " /"))==NULL) { panic(); }
		if(buf[0] == '/') { printf("skip\n"); continue; }
		*p = 0;
		memset(MC, 0, 1<<M0);
		mt_init();
		ini(16);
		O(val(chrs(buf)));
	}
}
I main(int args, C **argv){
	C buf[128];
	C *p, *b;
	I lb;
	MC=malloc(1<<M0);MI=(I*)MC;MJ=(J*)MC;MF=(F*)MC;
	if ((args == 2) && (!strcmp(argv[1], "t"))) {runtest(); exit(0);}
	memset(MC, 0, 1<<M0);
	mt_init();
	ini(16);
	if(args==2) {
		O(val(chrs(argv[1])));
		return 0;
	}
	b=malloc(1<<M0);lb=M0;
	printf(" ");
	while (fgets(buf, 128, stdin) != NULL) {
		if ((p=strchr(buf, '\r'))!=NULL) *p = 0;
		if ((p=strchr(buf, '\n'))!=NULL) *p = 0;
		if (!strcmp(buf, "\\\\")) exit(0);
		if (!strcmp(buf, "\\d")) dump(0, 200);
		else {
			if (!setjmp(jb)) {
				O(val(chrs(buf)));
				if(MI[32]!=lb) {
				 lb=MI[32];b=realloc(b,1<<lb);
				}
				memcpy(b, MC, 1<<M0);
	        	} else  memcpy(MC, b, 1<<M0);
			printf(" ");
		}
	}
}
