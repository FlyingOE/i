// compile without drawing
//  $ tcc -o kw.exe k_c
// compile with draw support (win32-only)
//  tcc's kernel32.def is missing the export for GetConsoleWindow.
//  append GetConsoleWindow to $tcc/lib/kernel32.def
//  $ tcc -o kw.exe -DDRW k_c -luser32 -lgdi32
//
// both use k_h+h_h which are autogenerated by "go test" from ../../k.w

#include<stdlib.h>
#include<stdio.h>
#include<stddef.h>
#include<setjmp.h>
#include<malloc.h>
#include<string.h>
#include<math.h>

#define R return
typedef void V;typedef unsigned char C;typedef uint32_t I;typedef uint64_t J;typedef double F;typedef int32_t SI;typedef int64_t SJ;
I __builtin_clz(I x){I r;__asm__("bsr %1, %0" : "=r" (r) : "rm" (x) : "cc");R r^31;}
C *MC;I* MI;J* MJ;F *MF;
static jmp_buf jb;
V panic(){printf("k.w:%u:%u\n", MI[140>>2], MI[144>>2]);longjmp(jb,1);}
V sC(I x,C y){MC[x]=y;}V sI(I x,I y){MI[x>>2]=y;}V sF(I x,F y){MF[x>>3]=y;}V sJ(I x,J y){MJ[x>>3]=y;};
//F NaN = &((unt64_t)9221120237041090561ull);
V dump(I,I);
I grow(I x){MC=realloc(MC, 1<<x);MI=(I*)MC;MJ=(J*)MC;MF=(F*)MC; R x;}
V printc(I x, I y) {for(I i=0;i<y;i++)putchar(MC[x+i]);putchar('\n');}

#ifndef DRW
V draw0(I x,I y,C *z){printf("draw..\n");}
V sleepms(I x){printf("sleep..\n");}
#else
#include<windows.h>
V sleepms(I x){Sleep(x);}
HBITMAP screenBitmap(HDC hdc, int w, int h, char *p) {
	BITMAPV5HEADER   bi;
	HBITMAP          hbm;
	char            *dst;
	ZeroMemory(&bi, sizeof(BITMAPV5HEADER));
	bi.bV5Size = sizeof(bi);
	bi.bV5Height = h; bi.bV5Width = w; bi.bV5Planes = 1; bi.bV5BitCount = 32; bi.bV5Compression = 3; 
	//bi.bV5XPelsPerMeter = 3780; bi.bV5YPelsPerMeter = 3780;
	bi.bV5RedMask = 0x000000FF; bi.bV5GreenMask = 0x0000FF00; bi.bV5BlueMask = 0x00FF0000, bi.bV5AlphaMask = 0xFF000000;
	hbm = CreateDIBSection(hdc, &bi, 0, &dst, 0, 0);
	if (hbm == NULL) {
        	// free(pbmi);
        	return NULL;
	}


	// Why is the image upside down?
	// memcpy(dst, p, 4*w*h);
	int32_t *idst = (int32_t*)dst;
	int32_t *ip   = (int32_t*)p;
	int h1 = h-1;
	for(int k=0;k<h;k++)for(int i=0;i<w;i++)idst[w*(h1-k)+i]=ip[w*k+i];


	return hbm;
}
void draw0(int w, int h, char *p) {
	HDC hdc = GetDC(GetConsoleWindow());
	HDC hdcmem = CreateCompatibleDC(hdc);
	HBITMAP hbm = screenBitmap(hdc, w, h, p);
	HGDIOBJ o;
	if (hbm == NULL) return;
	o = SelectObject(hdcmem, hbm);
	if (o == 0) return;
	BitBlt(hdc, 0, 0, w, h, hdcmem, 0, 0, 0x00CC0020);
	SelectObject(hdcmem, o);
	DeleteDC(hdcmem);
	DeleteDC(hbm);
}
#endif
V draw(I x, I y, I z){draw0(x,y,MC+z+8);}
#undef abs
#undef min
#undef max

#include"k_h"

V dump(I x, I n) {
	I p = x>>2;
	printf("%08x  ", x);
	for (I i=0; i<n; i++) {
		printf(" %08x", MI[p+i]);
		if ((i > x) && ((i+1)<n) && ((i+1)%8 == 0)) printf("\n%08x  ", x+4*i+4);
		else if ((i > 0) && ((i+1)%4 == 0)) printf(" ");
	}
	printf("\n ");
}
V pstr(I x) {
	I n = (MI[x>>2])&536870911;
	fwrite(MC+8+x, 1, n, stdout);
	dx(x);
}
V O(I x) { if(!x)R; pstr(kst(x)); printf("\n"); }
#define M0 16
I chrs(C *s) {
	I n = strlen(s);
	I x = mk(1, n);
	for (I i=0; i<n; i++) MC[8+x+i] = s[i];
	R x;
}
#include"h_h"
V runtest() {
	C buf[128];
	C *p;
	while (fgets(buf, 128, stdin) != NULL) {
		if((p=strstr(buf, " /"))==NULL) { panic(); }
		if(buf[0] == '/') { printf("skip\n"); continue; }
		*p = 0;
		memset(MC, 0, 1<<M0);
		mt_init();
		ini(16);
		O(val(chrs(buf)));
	}
}
I read0(C *name, I strip) {
	C b[512];
	size_t n;
	I s, r = mk(1, 0);
	FILE *f = fopen(name, "rt");
	if(f==NULL){ fprintf(stderr, "open %s\n", name); exit(1); }
	while((n=fread(b, 1, sizeof(b), f)) > 0) {
		for(I i=0; i<n; i++)if(b[i]=='\r')b[i]=' ';
		s = mk(1, n);
		memcpy(MC+s+8, b, n);
		r = ucat(r, s);
	}
	fclose(f);
	if(strip)r=fst(spl(r,flr(ucat(mki(10), mki(92))))); // ^\
	return r;
}
V fstore(C *var, C *file){
	if(!var[0]) var=file;
	dx(asn(sc(chrs(var)), 0, read0(file,0)));
}
V wsread(C *name){ 
	I n;
	FILE *f = fopen(name, "rb");
	if(f==NULL) { fprintf(stderr, "open %s\n", name); exit(1); }
	n = fread(MC, 1, 1<<M0, f);
	if(n != 1<<M0) { fprintf(stderr, "read %s\n", name); exit(1); }
	grow(M0);grow(MI[32]);
	if (MI[32] != M0) {
		n = (1<<(MI[32])) - (1<<M0);
		if(fread(MC+(1<<M0), 1, 1<<M0, f) != n) { fprintf(stderr, "read2 %s\n", name); exit(1); }
	}
}
V wswrite(I n) {
	FILE *f = fopen("k.ws", "wb");
	I r = fwrite(MC, 1, n, f);
	fclose(f);
	if(r!=n) fprintf(stderr, "k.ws write error\n");
	else     printf("wrote k.ws %d\n ", n);
}
V loop(I delay, I f){ for(I i=0;;i++){rx(f);O(cal(f,enl(mki(i))));sleepms(delay);} }
V usage(){ 
	fprintf(stderr, "%s\n", version);
	fprintf(stderr, "$ k [k.ws]  [f.k..] [-e]    load ws/file\n");
	fprintf(stderr, "$ k .. -e   [EXPR]          eval EXPR\n");
	fprintf(stderr, "$ k .. -L ms FRAME          call FRAME[i] in loop (ms delay)\n");
	fprintf(stderr, "$ ..|k -     EXPR           data as  l(lines)  x(numbers 2d)\n");
	fprintf(stderr, "$ ..|k -l    EXPR [-e..]    per line l(string) x(numbers 1d)\n");
	fprintf(stderr, "$ k -fVAR    FILE ..        store file(bytes) as VAR(def FILE)\n");
}
V SignalHandler(int signal) { printf("signal %d\n"); }
I main(int args, C **argv){
	C buf[128];
	C *p, *b, *a, *e, *f=NULL;
	I lb, n, d=0;
	MC=malloc(1<<M0);MI=(I*)MC;MJ=(J*)MC;MF=(F*)MC;
	if ((args == 2) && (!strcmp(argv[1], "t"))) {runtest(); exit(0);}
	memset(MC, 0, 1<<M0);
	mt_init();
	ini(M0);
	e = NULL;
	
	while(args>1){a=argv[1];n=strlen(a);
		     if((n>2)&&(a[n-2]=='.')&&(a[n-1]=='k'))                      O(val(read0(a,1)));    // *.k
		else if((n>3)&&(a[n-3]=='.')&&(a[n-2]=='w')&&(a[n-1]=='s'))                wsread(a);    // *.ws
		else if((n>1)&&(a[0]=='-')&&(a[1]=='f')&&(args>2)){fstore(a+2,argv[2]);args--;argv++;}   // -fVAR file
		else if((!strcmp(a, "-L"))&&(args>3)) {d=(I)atoi(argv[2]);f=argv[3]; args-=2;argv+=2;}   // -L ms FRAME
		else if( !strcmp(a, "-e"))            {if(args==2)e="";else{e=argv[2];args--;argv++;}}   // -e [EXPR]
		else { usage(); exit(1); }args--;argv++;
	}
	
	// nyi pipe mode(read all/lines)
	
	if(e!=NULL) { O(val(chrs(e)));return 0; }
	if(d>0){ n=val(chrs(f));if(n&&!tp(n))loop(d,n); }
	
	// interactive
	lb=1<<MI[32];b=malloc(1<<lb);
	printf("%s\n ", version);
	while (fgets(buf, 128, stdin) != NULL) {
		if ((p=strchr(buf, '\r'))!=NULL) *p = 0;
		if ((p=strchr(buf, '\n'))!=NULL) *p = 0;
		if (!strcmp(buf, "\\"))           help();
		if (!strcmp(buf, "\\\\"))         exit(0);
		if (!strcmp(buf, "\\d"))          dump(0, 200);
		else if (!strcmp(buf, "\\w"))     wswrite(1<<lb);
		else {
			if (!setjmp(jb)) {
				O(val(chrs(buf)));
				if(MI[32]!=lb) { lb=MI[32];b=realloc(b,1<<lb); }
				memcpy(b, MC, 1<<lb);
	        	} else  memcpy(MC, b, 1<<lb);
			printf(" ");
		}
	}
}
